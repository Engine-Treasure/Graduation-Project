# 遗传算法 (GA) 学习笔记

> 一言以蔽之: 用生物进化的过程, 来模拟问题求解的过程, 通过选择(复制), 交叉, 突变等操作产生下一代的解, 并逐步淘汰掉适应度函数值低的解, 增加适应度函数值高的解. 经过 N 代进化, 可能会进化出适应度函数值很高的个体 (近似最优解).

> 遗传算法是计算数学中用于解决`最优化问题`的搜索算法.

## 术语 
- 种群 (population):
- 基因 (gene):
- 染色体 (chromosome):
-

## GA 特点

- 优
    - 群体搜索, 易于并行化处理;
    - 不是盲目穷举，而是启发式搜索;
    - 适应度函数不受连续, 可微等条件的约束, 适用范围很广
    - 容易实现. 一旦有了一个遗传算法的程序, 如果想解决一个新的问题, 只需针对新的问题重新进行基因编码就行; 如果编码方法也相同, 那只需要改变一下适应度函数就可以了
- 缺
    - 全局搜索能力不强, 很容易陷入局部最优解跳不出来; (可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高)
- 遗传算法最大的优点在于不必去了解和操心如何寻找最优解, 而只要`否定`一些表现不好的个体就行了

## GA 的组成

- 实现过程:
    - 寻找一种对问题潜在解进行"数字化"`编码`的方案, `建立表现型与基因型的映射关系`
    - 随机初始化
    - 解码得到数据个体, 用适应度函数对每个基因个体做适应度评估
    - `选择`, `交叉`, `变异`
- 组成部分:
    - 编码- 产生初始种群
    - 适应度函数
    - 遗传算子 - 选择, 交叉, 变异
    - 运行参数: 遗传算法包含大量可控参数, 比如进化代数, 人口数目, 选择概率, 交叉概率, 变异概率, 变异步长...

### 编码

- 将问题的解编码成字符串的形式
- 常见的编码方式：
    - 二进制编码 (常用于解决 01 背包问题): 简单直观, 但当个体特征比较复杂时, 需要大量编码才能精确描述, 相应的解码过程也过分繁复
        - 改进方案: 动态编码, 实数编码
    - 互换编码 (用于解决排序问题)
    - 树形编码 (用于遗传规划中的演化编程或表示)
    - 真实值编码 (浮点数编码): 类似 `1.2 – 3.3 – 2.0 –5.4 – 2.7 – 4.3`
    - 整数编码
    - 排列编码 (旅行商问题)
- 遗传算法编码, 必须将具体问题抽象成数学模型, 突出主要矛盾, 舍弃次要矛盾. 简洁有效地解决问题

### 适应度函数

- 适应度函数与目标函数是正相关的, 可对目标函数作一些变形得到适应度函数

### 遗传算子

> 遗传算法本质上是对染色体模式所进行的一系列运算，即通过选择算子将当前种群中的优良模式遗传到下一代种群中，利用交叉算子进行模式重组，利用变异算子进行模式突变。

### 父母选择

- GA 应该能相当高效地计算适应度值, 因为适应度的计算在 GA 运行过程中一直在进行
- 父母的选择:
    - 适应度最佳选择:
        - 轮盘赌 - 到最后, 个体的适应度接近时, 退化为随机选择了
        - SUS (随机通用样例)
            - 类似于轮盘赌, 但一次选出多个值. 一次旋转, 高适应度的个体可能会被多次选择
    - 竞争选择 - 像比赛一样, 竞选出最佳的个体
    - 排名选择 - 在种群中个体的适应度相差很小的情况下 (算法即将结束), 使用最多. 每个个体按适应度高低排序, 按排名选择.
    - 随机选择 - 一般不使用
    - 种群的规模. 实验发现, 比较大的种群的规模并不能优化遗传算法的结果. 种群规模的大小取决于编码的方式
    - 终止进化代数. 连续 N 代出现的最优个体的适应度都一样时 (严格地说, 连续 N 代子代种群的最优个体适应度都 <= 父代最优个体的适应度)

## 基本遗传算法的优化

- 灾变
- 精英主义 (Elitist Strategy) 选择
- 矛盾

### 灾变

- 遗传算法的局部搜索能力较强, 但是很容易陷入局部极值
- 灾变就是杀掉最优秀的个体, 这样才可能产生更优秀的物种
- 何时进行灾变, 可以采用`灾变倒计数`的方式. 如果n代还没有出现比之前更优秀的个体时, 可以发生灾变. 灾变次数可以这样来确定, 如果若干次灾变后产生的个体的适应度与没灾变前的一样可停止灾变

### 精英主义选择

- 当利用交叉和变异产生新的一代时, 有很大的可能把在某个中间步骤中得到的最优解丢失
- 精英主义的思想: 当前最优解原封不动复制到新一代中

### 矛盾

### 插入操作

- 插入操作将染色体中的某个随机的片段移位到另一个随机的位置

### 伪代码

```python
/*
* Pc：交叉发生的概率
* Pm：变异发生的概率
* M：种群规模
* G：终止进化的代数
* Tf：进化产生的任何一个个体的适应度函数超过Tf，则可以终止进化过程
*/
初始化Pm，Pc，M，G，Tf等参数。随机产生第一代种群Pop

do
{
　　计算种群Pop中每一个体的适应度F(i)。
　　初始化空种群newPop
　　do
　　{
　　　　根据适应度以比例选择算法从种群Pop中选出2个个体
　　　　if ( random ( 0 , 1  ) < Pc  )
　　　　{
　　　　　　对2个个体按交叉概率Pc执行交叉操作
　　　　
        }
　　　　if ( random ( 0 , 1  ) < Pm  )
    　　　　{
　　　　　　对2个个体按变异概率Pm执行变异操作
　　　　
        }
    将2个新个体加入种群newPop中
    } until (M 个子代被创建)

用newPop取代Pop
}until (任何染色体得分超过Tf, 或繁殖代数超过G)
```
# 遗传算法 (GA) 学习笔记

> 一言以蔽之: 用生物进化的过程, 来模拟问题求解的过程, 通过选择(复制), 交叉, 突变等操作产生下一代的解, 并逐步淘汰掉适应度函数值低的解, 增加适应度函数值高的解. 经过 N 代进化, 可能会进化出适应度函数值很高的个体 (近似最优解).

> 遗传算法是计算数学中用于解决`最优化问题`的搜索算法.

## 术语

- 种群 (population):
- 基因 (gene):
- 染色体 (chromosome):
-

## GA 特点

- 优
    - 群体搜索, 易于并行化处理;
    - 不是盲目穷举，而是启发式搜索;
    - 适应度函数不受连续, 可微等条件的约束, 适用范围很广
    - 容易实现. 一旦有了一个遗传算法的程序, 如果想解决一个新的问题, 只需针对新的问题重新进行基因编码就行; 如果编码方法也相同, 那只需要改变一下适应度函数就可以了
- 缺
    - 全局搜索能力不强, 很容易陷入局部最优解跳不出来; (可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高)

　　　　根据适应度以比例选择算法从种群Pop中选出2个个体
　　　　if ( random ( 0 , 1  ) < Pc  )
　　　　{
　　　　　　对2个个体按交叉概率Pc执行交叉操作
　　　　
        }
　　　　if ( random ( 0 , 1  ) < Pm  )
    　　　　{
　　　　　　对2个个体按变异概率Pm执行变异操作
　　　　
        }
    将2个新个体加入种群newPop中
    } until (M 个子代被创建)

用newPop取代Pop
}until (任何染色体得分超过Tf, 或繁殖代数超过G)
```

## 其他

### 遗传算法模型

- 除了达尔文进化模型, 还存在其他生命周期适应, 应该具体问题, 选择相应的模型.
- 其他模型生命周期适应模型 (非达尔文进化模型):
    - 拉马克模型 (Lamarckian): 个体的特征是传递给后代的. 在拉马克模型中, 局部搜索算子检查邻域(获取新的性状), 如果找到更好的染色体, 将成为后代
    - 鲍德温模型 (Baldwinian): 染色体可以编码学习有益的趋势. (有别于拉马克模型的需要传递特征, 也有别于达尔文模型的完全忽略特征). 搜索邻域, 发现更好的染色体, 则用于改进适应性, 而不修改染色体本身. 适应性的变化表示染色体"获得特征"的能力, 即使它不直接传给后代.

### 种群初始化方式

- 种群初始化方式:
    - 随机初始化
    - 启发式初始化
- 对于整个种群使用启发式初始化, 会导致多样性的缺失. 启发式初始化应只用于设置一些优选个体, 剩余的个体用随机初始化补全
- 在一些例子中, 启发式初始化只会影响种群的初始适应度, 最终还是由解的多样性决定最优解

### 种群模型

- 种群模型
    - 稳定状态 (增量型) - 每一代, 只生成一两个个后代, 并替换掉上一代中的一两个个体.
    - 世代型- 产生 n 个后代, 完全替换掉上一代种群
- Keep in mind when dealing with GA population:
    - The diversity of the population should be maintained otherwise it might lead to premature convergence. (保持种群多样性, 以避免过早收敛)
    - 种群规模过大, 计算缓慢; 过小, 得不到全局最优解

### 遗传终止条件

- 终止条件:
    - 种群多次迭代都没有更好的解了
    - 达到某一迭代次数
    - 当可观测函数值达到某一预定义值
        - 启动一个计数器, 若出现更优解, 重置计数; 否则当数值达到某一预定义值, 结束迭代
