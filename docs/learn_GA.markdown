# 遗传算法 (GA) 学习笔记

> 一言以蔽之: 用生物进化的过程, 来模拟问题求解的过程, 通过选择(复制), 交叉, 突变等操作产生下一代的解, 并逐步淘汰掉适应度函数值低的解, 增加适应度函数值高的解. 经过 N 代进化, 可能会进化出适应度函数值很高的个体 (近似最优解).

> 遗传算法是计算数学中用于解决`最优化问题`的搜索算法.

> 遗传算法中, 没有完美的解能适用于所有问题. 即使 GA 已经初始化完成, 也需要花时间调整参数.

## 术语
- 种群 (population):
- 基因 (gene):
- 染色体 (chromosome):
-

## GA 特点

- 优
    - 群体搜索, 易于并行化处理;
    - 不是盲目穷举，而是启发式搜索;
    - 适应度函数不受连续, 可微等条件的约束, 适用范围很广
    - 容易实现. 一旦有了一个遗传算法的程序, 如果想解决一个新的问题, 只需针对新的问题重新进行基因编码就行; 如果编码方法也相同, 那只需要改变一下适应度函数就可以了
- 缺
    - 全局搜索能力不强, 很容易陷入局部最优解跳不出来; (可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高)
- 遗传算法最大的优点在于不必去了解和操心如何寻找最优解, 而只要`否定`一些表现不好的个体就行了

## GA 的组成

- 实现过程:
    - 寻找一种对问题潜在解进行"数字化"`编码`的方案, `建立表现型与基因型的映射关系`
    - 随机初始化
    - 解码得到数据个体, 用适应度函数对每个基因个体做适应度评估
    - `选择`, `交叉`, `变异`
- 组成部分:
    - 编码- 产生初始种群
    - 适应度函数
    - 遗传算子 - 选择, 交叉, 变异
    - 运行参数: 遗传算法包含大量可控参数, 比如进化代数, 人口数目, 选择概率, 交叉概率, 变异概率, 变异步长...

### 编码

- 将问题的解编码成字符串的形式
- 常见的编码方式：
    - 二进制编码 (常用于解决 01 背包问题): 简单直观, 但当个体特征比较复杂时, 需要大量编码才能精确描述, 相应的解码过程也过分繁复
        - 改进方案: 动态编码, 实数编码
    - 互换编码 (用于解决排序问题)
    - 树形编码 (用于遗传规划中的演化编程或表示)
    - 真实值编码 (浮点数编码): 类似 `1.2 – 3.3 – 2.0 –5.4 – 2.7 – 4.3`
    - 整数编码
    - 排列编码 (旅行商问题)
- 遗传算法编码, 必须将具体问题抽象成数学模型, 突出主要矛盾, 舍弃次要矛盾. 简洁有效地解决问题

### 适应度函数

- 适应度函数与目标函数是正相关的, 可对目标函数作一些变形得到适应度函数

### 遗传算子

> 遗传算法本质上是对染色体模式所进行的一系列运算，即通过选择算子将当前种群中的优良模式遗传到下一代种群中，利用交叉算子进行模式重组，利用变异算子进行模式突变。

### 父母选择

- GA 应该能相当高效地计算适应度值, 因为适应度的计算在 GA 运行过程中一直在进行
- 父母的选择:
    - 适应度最佳选择:
        - 轮盘赌 - 到最后, 个体的适应度接近时, 退化为随机选择了
        - SUS (随机通用样例)
            - 类似于轮盘赌, 但一次选出多个值. 一次旋转, 高适应度的个体可能会被多次选择
    - 竞争选择 - 像比赛一样, 竞选出最佳的个体
    - 排名选择 - 在种群中个体的适应度相差很小的情况下 (算法即将结束), 使用最多. 每个个体按适应度高低排序, 按排名选择.
    - 随机选择 - 一般不使用
    - 种群的规模. 实验发现, 比较大的种群的规模并不能优化遗传算法的结果. 种群规模的大小取决于编码的方式
    - 终止进化代数. 连续 N 代出现的最优个体的适应度都一样时 (严格地说, 连续 N 代子代种群的最优个体适应度都 <= 父代最优个体的适应度)

## 基本遗传算法的优化

- 灾变
- 精英主义 (Elitist Strategy) 选择
- 矛盾

### 灾变

- 遗传算法的局部搜索能力较强, 但是很容易陷入局部极值
- 灾变就是杀掉最优秀的个体, 这样才可能产生更优秀的物种
- 何时进行灾变, 可以采用`灾变倒计数`的方式. 如果n代还没有出现比之前更优秀的个体时, 可以发生灾变. 灾变次数可以这样来确定, 如果若干次灾变后产生的个体的适应度与没灾变前的一样可停止灾变

### 精英主义选择

- 当利用交叉和变异产生新的一代时, 有很大的可能把在某个中间步骤中得到的最优解丢失
- 精英主义的思想: 当前最优解原封不动复制到新一代中

### 矛盾

### 插入操作

- 插入操作将染色体中的某个随机的片段移位到另一个随机的位置

### 伪代码

```python
/*
* Pc：交叉发生的概率
* Pm：变异发生的概率
* M：种群规模
* G：终止进化的代数
* Tf：进化产生的任何一个个体的适应度函数超过Tf，则可以终止进化过程
*/
初始化Pm，Pc，M，G，Tf等参数。随机产生第一代种群Pop

do
{
　　计算种群Pop中每一个体的适应度F(i)。
　　初始化空种群newPop
　　do
　　{
　　　　根据适应度以比例选择算法从种群Pop中选出2个个体
　　　　if ( random ( 0 , 1  ) < Pc  )
　　　　{
　　　　　　对2个个体按交叉概率Pc执行交叉操作
　　　　
        }
　　　　if ( random ( 0 , 1  ) < Pm  )
    　　　　{
　　　　　　对2个个体按变异概率Pm执行变异操作
　　　　
        }
    将2个新个体加入种群newPop中
    } until (M 个子代被创建)

用newPop取代Pop
}until (任何染色体得分超过Tf, 或繁殖代数超过G)
```

## 其他

### 遗传算法模型

- 除了达尔文进化模型, 还存在其他生命周期适应, 应该具体问题, 选择相应的模型.
- 其他模型生命周期适应模型 (非达尔文进化模型):
    - 拉马克模型 (Lamarckian): 个体的特征是传递给后代的. 在拉马克模型中, 局部搜索算子检查邻域(获取新的性状), 如果找到更好的染色体, 将成为后代
    - 鲍德温模型 (Baldwinian): 染色体可以编码学习有益的趋势. (有别于拉马克模型的需要传递特征, 也有别于达尔文模型的完全忽略特征). 搜索邻域, 发现更好的染色体, 则用于改进适应性, 而不修改染色体本身. 适应性的变化表示染色体"获得特征"的能力, 即使它不直接传给后代.

### 种群初始化方式

- 种群初始化方式:
    - 随机初始化
    - 启发式初始化
- 对于整个种群使用启发式初始化, 会导致多样性的缺失. 启发式初始化应只用于设置一些优选个体, 剩余的个体用随机初始化补全
- 在一些例子中, 启发式初始化只会影响种群的初始适应度, 最终还是由解的多样性决定最优解

### 种群模型

- 种群模型
    - 稳定状态 (增量型) - 每一代, 只生成一两个个后代, 并替换掉上一代中的一两个个体.
    - 世代型- 产生 n 个后代, 完全替换掉上一代种群
- Keep in mind when dealing with GA population:
    - The diversity of the population should be maintained otherwise it might lead to premature convergence. (保持种群多样性, 以避免过早收敛)
    - 种群规模过大, 计算缓慢; 过小, 得不到全局最优解

### 遗传终止条件

- 终止条件:
    - 种群多次迭代都没有更好的解了
    - 达到某一迭代次数
    - 当可观测函数值达到某一预定义值
        - 启动一个计数器, 若出现更优解, 重置计数; 否则当数值达到某一预定义值, 结束迭代

### 问题域

- 将更多的特定问题的领域知识加入 GA, 可以得到更好的客观值.
- 可通过使用特定问题的交叉或突变算子, 或者自定义表示模型加入领域知识
- 当很多高度适合的染色体被重复生产时, 就表示发生了聚合, 种群中将充斥着相似的具有相似适应度的解. 这减少了多样性.
- 防止聚合的几种手段:
    - 变异产生多样性
    - 使用排名选择和竞赛选择
    - 适应度共享 - 如果种群中已经包含相似的个体时, 减少它们的适应度
- 实验证明, 最好的解是随机染色体驱动的, 因为它们增加了种群的多样性. 因此, 编写 GA 时, 要保持足够的随机化和多样性以获得最优解.

### 混合局部搜索

- 局部搜索是指在给定解的邻域内查找更优的观测值

![hybridize_ga](hybridize_ga.jpg)

## Advanced Topics

### 约束优化问题

- 所谓约束优化问题是, 给定观测函数值有最大最小值的. 在此范围内为可行解
- 对于约束优化问题, 交叉与变异可能会产生不可行的解. 因此, 需要引入额外的方法:
    - 使用`惩罚函数`降低不可行解的适应度
    - 使用`修复函数`, 将不可行解修复成满足约束的
    - 禁止不可行解加入种群
    - 使用特殊的表现型或解码函数确保解的可行性

### 基本理论背景

- 模式定理 (Schema Theorem)
    - Schema 是模板, `*` 通配所有值
    - Schema 的顺序是基因中固定位置的数量
    - 定义长度是基因中两个最远的固定符号 (非\*) 的距离
- 模式定理表明: 模式具有平均适应度,定义长度越短, 顺序排名越小, 模式存活, 交叉, 变异的可能性更大
- 构建块是具有平均适应度的低顺序低定义长度的模式. (???不解)
- "没有免费的午餐"理论 - GA 的针对性越强, 性能就越强.

### 基于 GA 的机器学习

- 分类器 (Classifier) 系统是基于遗传学的机器学习 (Genetics-Based Machine Learning) 系统的一种形式.
- GBML 的系统的两种形式
    - The Pittsburg Approach (匹兹堡方法) - 一个染色体编码成一个解, fitness is assigned to solutions.
    - The Michigan Approach (密歇根方法) - 一个解用多个染色体表示, fitness is assigned to partial solutions.

### 应用领域

- 遗传算法主要用于解决各类优化问题, 同时也频繁地用于其他应用领域
- 遗传算法的主要应用领域:
    - 优化问题 (Optimization)
    - 经济学 (Economics) - 表征各种经济模型, 如蛛网模型, 博弈理论均衡分解, 资产定价等
    - 神经网络 (Neural Networks) - 训练神经网络, 特别是循环神经网络
    - 并行问题 (Parallelization) - GA 具有良好的并行能力
    - 图像处理 (Image Processing) - GA 可用于不同数字图像处理, 密集像素匹配
    - 车辆路由问题 (Vehicle routing problem) - 具有多个软时间窗口, 多个车站和异构车队的问题
    - 调度应用 (Scheduling Application) - 尤其是时间表问题
    - 机器学习 (Machine Learning)
    - 机器人轨迹 (Robot Trajectory Generation)
    - 飞机参数设计 (Parametric Design of Aircraft)
    - DNA 分析 (DNA Analysis)
    - 多模型优化 (Multimodal Optimization)
    - 旅行商问题 (TSP)
